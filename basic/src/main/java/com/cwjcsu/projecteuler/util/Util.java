package com.cwjcsu.projecteuler.util;import java.io.*;import java.math.BigInteger;import java.util.ArrayList;import java.util.BitSet;import java.util.List;public class Util {	/**	 * 是否是奇数	 */	public static boolean isEven(int i) {		return (i & 1) == 0;	}	/**	 * 	 * 	 * @param i	 * @return	 */	public static boolean isEven(long i) {		return (i & 1) == 0;	}	public static boolean isEven(BigInteger i) {		return isEven(i.intValue());	}	public final static int[] sizeTable = { 9, 99, 999, 9999, 99999, 999999,			9999999, 99999999, 999999999, Integer.MAX_VALUE };	/**	 * POWER_OF_TEN[i] is 10<sup>i</sup>,i from [0,10]	 */	public final static int[] POWER_OF_TEN = { 1, 10, 100, 1000, 10000, 100000,			1000000, 10000000, 100000000, 1000000000 };	/**	 * 10的幂，POWER_OF_TEN_LONG[i]是10^i,i from [0,18]	 */	public final static long[] POWER_OF_TEN_LONG = { 1, 10, 100, 1000, 10000,			100000, 1000000, 10000000, 100000000, 1000000000, 10000000000L,			100000000000L, 1000000000000L, 10000000000000L, 100000000000000L,			1000000000000000L, 10000000000000000L, 100000000000000000L,			1000000000000000000L, 1000000000000000000L };	/**	 * number of digits	 */	public static int size0(int d) {		if (d == Integer.MIN_VALUE)			return 10;		if (d < 0) {			d = -d;		}		for (int i = 0;; i++)			if (d <= sizeTable[i])				return i + 1;	}	/**	 * number of digits	 */	public static int size(BigInteger n) {		return n.abs().toString().length();	}	/**	 * number of digits	 */	public static int size(long n) {		if (n == 0) {			return 0;		} else if (n < 0) {			return ((int) Math.log10(Math.abs(n))) + 1;		} else {			return ((int) Math.log10(n)) + 1;		}	}	/**	 * input 12345,output 54321 as long because some numbers will exceed the max	 * int.	 * 	 * @param n	 * @return	 */	public static int reverse(int n) {		int r = 0;		int n0 = n;		while (n > 0) {			r = r * 10 + n % 10;			n /= 10;		}		if (r < 0) {			throw new RuntimeException("number overflow:" + n0);		}		return r;	}	public static boolean isPalindrome(int d) {		return d == reverse(d);	}	/**	 * 是否数字全是偶数	 */	public static boolean isDigitsOdd(int n) {		if (n < 0) {			n = -n;		}		while (n > 0) {			if (isEven(n % 10))				return false;			n /= 10;		}		return true;	}	/**	 * 获取由数字组成的数组	 */	public static int[] toDigit(long d) {		int size = size(d);		int[] ret = new int[size];		while (d > 0) {			ret[--size] = (int) d % 10;			d /= 10;		}		return ret;	}	/**	 * 获取由数字组成的数组	 */	public static int[] toDigit(BigInteger d) {		String ds = d.toString(10);		int[] ret = new int[ds.length()];		for (int i = 0; i < ret.length; i++) {			ret[i] = ds.charAt(i) - '0';		}		return ret;	}	/**	 * 获取由数字组成的数组	 */	public static int[] toDigit(int d) {		return toDigit((long) d);	}	/**	 * 获取由数字组成的数组	 */	public static int[] toDigit(String ds) {		int[] ret = new int[ds.length()];		for (int i = 0; i < ds.length(); i++) {			ret[i] = (ds.charAt(i) - '0');		}		return ret;	}	/**	 * 把数字数组合并成字符串	 */	public static String asString(int[] data) {		StringBuffer sb = new StringBuffer();		for (Object o : data) {			sb.append(String.valueOf(o));		}		return sb.toString();	}	/**	 * 最大公约数-辗转相除法	 */	public static long gcd(long m, long n) {		if (m < n) {			return gcd(n, m);		} else if (m == n) {			return m;		}		while (n > 0) {			long tmp = m % n;			m = n;			n = tmp;		}		return m;	}	/**	 * 最大公约数-辗转相除法	 */	public static int gcd(int m, int n) {		if (m < n) {			return gcd(n, m);		} else if (m == n) {			return m;		}		while (n > 0) {			int tmp = m % n;			m = n;			n = tmp;		}		return m;	}	/**	 * m>n,m是否能被n整除	 */	public static boolean divided(int m, int n) {		return m % n == 0;	}	/**	 * 第N个三角数	 */	public static int getNthTriangleNumber(int N) {		return (1 + N) * N / 2;	}	/**	 * 第N个三角数	 */	public static long getNthTriangleNumber(long N) {		return (1 + N) * N / 2;	}	/**	 * not impl	 * 	 * @param e	 * @param primes	 * @return	 */	static int[] getDivisor(int e, int[] primes) {		int[] prim = getPrimeDivisors(e, primes);		return null;	}	public static int getDivisorCount(int[] factors) {		int count = 1;		int cc = 0;		int f = 0;		for (int d : factors) {			if (d == f) {				cc++;			} else {				count *= (cc + 1);				cc = 1;				f = d;			}		}		count *= (cc + 1);		return count;	}	/**	 * 获取不超过ex的素数表-欧拉线性筛法。 根据“每个合数都可以分解成它的 质因数之积”，因此每个合数只需要被它的最小质因数筛除。	 * 时间复杂度O(n)，空间复杂度O(n)	 * 	 * @return	 */	public static int[] getPrimesBlow(int ex) {		BitSet isPrime = new BitSet(ex + 1);		isPrime.set(0, ex, true);		// TODO 利用素数公式优化内存消耗		int[] prime = new int[ex + 1];		int total = 0;		for (int i = 2; i <= ex; i++) {			if (isPrime.get(i)) {				prime[total++] = i;			}			for (int j = 0; j < total && i * prime[j] <= ex; j++) {				isPrime.set(i * prime[j], false);				if (i % prime[j] == 0) {// 合数i被它的最小质因数prime[j]筛掉					break;				}			}		}		int[] ret = new int[total];		System.arraycopy(prime, 0, ret, 0, total);		return ret;	}	/**	 * 获取不超过ex的所有数是否是素数的决策表	 * 	 * @param ex	 * @return	 */	public static boolean[] getPrimeDecisionBlow(int ex) {		boolean[] isPrime = new boolean[ex + 1];		int[] prime = new int[ex + 1];		int total = 0;		for (int i = 0; i < isPrime.length; i++) {			isPrime[i] = true;		}		for (int i = 2; i <= ex; i++) {			if (isPrime[i]) {				prime[total++] = i;			}			for (int j = 0; j < total && i * prime[j] <= ex; j++) {				isPrime[i * prime[j]] = false;				if (i % prime[j] == 0)					break;			}		}		return isPrime;	}	/**	 * 获取不超过ex的所有数是否是素数的决策表，用BitSet表示,BitSet.get(i),i from [2,ex]	 * 	 * @param ex	 * @return	 */	public static BitSet getPrimeDecisionBlow2(int ex) {		BitSet isPrime = new BitSet(ex + 1);		for (int i = 2; i < ex + 1; i++) {			isPrime.set(i);		}		int[] prime = new int[ex + 1];		int total = 0;		for (int i = 2; i <= ex; i++) {			if (isPrime.get(i)) {				prime[total++] = i;			}			for (int j = 0; j < total && i * prime[j] <= ex; j++) {				isPrime.set(i * prime[j], false);				if (i % prime[j] == 0)					break;			}		}		return isPrime;	}	/**	 * 埃氏筛法。算法思想：先用2去筛，即把2留下，把2的倍数剔除掉；再用下一个素数，也就是3筛，把3留下，把3的倍数剔除掉；接下去用下一个素数5筛，	 * 把5留下，把5的倍数剔除掉；不断重复下去。时间复杂度O(n loglogn)，空间复杂度是O(n)。	 * 缺点：有很多合数被重复筛，比如6，被2筛掉，也被3筛掉。	 * 	 * @param ex	 * @return	 */	static int[] getPrimesBlowEratosthenes(int ex) {		BitSet isPrime = new BitSet(ex + 1);		int[] prime = new int[ex + 1];		int total = 0;		isPrime.set(0, ex, true);		int p = 2;		int j = p * p;		while ((j = p * p) <= ex) {			while (j <= ex) { // 筛除所有p的倍数				isPrime.clear(j);				j = j + p;			}			do {				p++;// 找到下一个素数，继续筛			} while (isPrime.get(p) != true);		}		for (int i = 2; i <= ex; i++) {			if (isPrime.get(i)) {				prime[total++] = i;			}		}		int[] ret = new int[total];		System.arraycopy(prime, 0, ret, 0, total);		return ret;	}	/**	 * 给定质素表，求n的质因数	 * 	 * @param n	 * @param primes	 * @return	 */	public static int[] getPrimeDivisors(int n, int[] primes) {		int[] prim = new int[primes.length];		int p = 0;		int j = 0;		for (int i = 0; (p = primes[i]) <= n;) {			if (n % p == 0) {				n /= p;				prim[j++] = p;			} else {				i++;			}		}		int ret[] = new int[j];		System.arraycopy(prim, 0, ret, 0, j);		return ret;	}	/**	 * 给定质素表，求n的质因数	 * 	 * @param n	 * @param primes	 * @return	 */	public static List<PrimeDivisor> getPrimeDivisors2(int n, int[] primes) {		int[] divisors = getPrimeDivisors(n, primes);		List<PrimeDivisor> divisorList = new ArrayList<PrimeDivisor>();		PrimeDivisor curr = null;		for (int i = 0; i < divisors.length; i++) {			if (curr == null) {				curr = new PrimeDivisor(divisors[i]);				divisorList.add(curr);			} else if (curr.divisor == divisors[i]) {				curr.power++;			} else {				curr = null;				i--;			}		}		return divisorList;	}	public static List<int[]> getPrimeDivisors4(int n, int[] primes) {		List<int[]> divisorList = new ArrayList<int[]>();		int d = n;		for (int i = 0; i < primes.length; i++) {			int prime = primes[i];			if (prime * prime > n) {				break;			}			int e = 0;			while (d % prime == 0) {				e++;				d = d / prime;			}			if (e > 0) {				divisorList.add(new int[] { prime, e });			}		}		if (d > 1) {			divisorList.add(new int[] { d, 1 });		}		if (divisorList.size() == 0) {			divisorList.add(new int[] { 1, 0 });		}		return divisorList;	}	public static List<PrimeDivisor> getPrimeDivisors3(int n, int[] primes) {		List<PrimeDivisor> divisorList = new ArrayList<PrimeDivisor>();		int d = n;		for (int i = 0; i < primes.length; i++) {			int prime = primes[i];			if (prime * prime > n) {				break;			}			int e = 0;			while (d % prime == 0) {				e++;				d = d / prime;			}			if (e > 0) {				divisorList.add(new PrimeDivisor(prime, e));			}		}		if (d > 1) {			divisorList.add(new PrimeDivisor(d, 1));		}		if (divisorList.size() == 0) {			divisorList.add(new PrimeDivisor(1, 0));		}		return divisorList;	}	public static class PrimeDivisor {		public PrimeDivisor(int divisor) {			this.divisor = divisor;			this.power = 1;		}		public PrimeDivisor(int divisor, int power) {			super();			this.divisor = divisor;			this.power = power;		}		public int divisor;		public int power;		@Override		public String toString() {			if (power > 1) {				return divisor + "^" + power;			}			return String.valueOf(divisor);		}	}	/**	 * get divisor count of n	 * 	 * @param n	 * @param primes	 * @return	 */	public static int countDivisors(int n, int[] primes) {		List<PrimeDivisor> divisor = getPrimeDivisors2(n, primes);		int multi = 1;		for (int i = 0; i < divisor.size(); i++) {			multi *= (divisor.get(i).power + 1);		}		return multi;	}	/**	 * 	 * @param d	 * @return	 */	public static long sum(long[] d) {		long s = 0;		for (int i = 0; i < d.length; i++) {			s += d[i];		}		return s;	}	/**	 * 	 * @param d	 * @return	 */	public static long sum(int[] d) {		long s = 0;		for (int i = 0; i < d.length; i++) {			s += d[i];		}		return s;	}	public static int sum(int[] d, int s, int e) {		int sum = 0;		for (int i = s; i <= e; i++) {			sum += d[i];		}		return sum;	}	public static int multiple(int[] d) {		int m = 1;		for (int dd : d) {			m *= dd;		}		return m;	}	public static int min(int[] d) {		return min(d, 0, d.length - 1);	}	public static int max(int[] d) {		return max(d, 0, d.length - 1);	}	public static int min(int[] d, int s, int e) {		int min = Integer.MAX_VALUE;		for (int i = s; i <= e; i++) {			if (d[i] < min) {				min = d[i];			}		}		return min;	}	public static int max(int[] d, int s, int e) {		int max = Integer.MIN_VALUE;		for (int i = s; i <= e; i++) {			if (d[i] > max) {				max = d[i];			}		}		return max;	}	public static int[][] transportMatrix(int[][] d) {		int[][] t = new int[d[0].length][d.length];		for (int i = 0; i < d.length; i++) {			for (int j = 0; j < d[i].length; j++) {				t[j][i] = d[i][j];			}		}		return t;	}	/**	 * digitFactorials[i] = i!,i from [0,12],fact[13] out of int range	 */	private static int[] digitFactorials = { 1, 1, 2, 6, 24, 120, 720, 5040,			40320, 362880, 3628800, 39916800, 479001600 };	/**	 * digitPower2[i] = i*i	 */	private static int[] digitPower2 = { 0, 1, 4, 9, 16, 25, 36, 49, 64, 81 };	//	private static int[] digitPower3 = { 0, 1, 8, 27, 64, 125, 216, 343, 512,			729 };	private static int[] digitPower4 = { 0, 1, 16, 81, 256, 625, 1296, 2401,			4096, 6561 };	private static int[] digitPower5 = { 0, 1, 32, 243, 1024, 3125, 7776,			16807, 32768, 59049 };	/**	 * 	 * @param d	 * @return	 */	public static int digitFactorial(int d) {		if (d >= 0 && d <= 9)			return digitFactorials[d];		throw new RuntimeException("Not a one digit number:" + d);	}	public static int digitPower2(int d) {		if (d >= 0 && d <= 9)			return digitPower2[d];		throw new RuntimeException("Not a one digit number:" + d);	}	public static int digitPower3(int d) {		if (d >= 0 && d <= 9)			return digitPower3[d];		throw new RuntimeException("Not a one digit number:" + d);	}	public static int digitPower4(int d) {		if (d >= 0 && d <= 9)			return digitPower4[d];		throw new RuntimeException("Not a one digit number:" + d);	}	public static int digitPower5(int d) {		if (d >= 0 && d <= 9)			return digitPower5[d];		throw new RuntimeException("Not a one digit number:" + d);	}	/**	 * 	 * 欧拉筛法 求n<=ex的欧拉函数值，返回 phi[i]	 * 	 * phi(n)是小于或等于n的正整数中与n互质的数的数目	 */	public static int[] phi(int ex) {		BitSet isPrime = new BitSet(ex + 1);		isPrime.set(0, ex, true);		int[] prime = new int[ex + 1];		int[] phi = new int[ex + 1];		phi[0] = 0;		phi[1] = 1;		int total = 0;		for (int i = 2; i <= ex; i++) {			if (isPrime.get(i)) {				prime[total++] = i;				phi[i] = i - 1;			}			for (int j = 0; j < total && i * prime[j] <= ex; j++) {				isPrime.set(i * prime[j], false);				if (i % prime[j] == 0) {					phi[i * prime[j]] = phi[i] * prime[j];					break;				} else {					phi[i * prime[j]] = phi[i] * (prime[j] - 1);				}			}		}		return phi;	}	/**	 * read 2d int array from file	 * 	 * @param file	 * @param splitChar	 * @return	 * @throws IOException	 */	public static int[][] readIntArray(File file, String splitChar)			throws IOException {		List<int[]> datas = new ArrayList<int[]>();		InputStream is = new FileInputStream(file);		BufferedReader reader = new BufferedReader(new InputStreamReader(is));		String line = null;		while ((line = reader.readLine()) != null) {			String[] nums = line.split(",");			int[] data = new int[nums.length];			for (int i = 0; i < nums.length; i++) {				data[i] = Integer.valueOf(nums[i]);			}			datas.add(data);		}		int[][] ret = new int[datas.size()][];		for (int i = 0; i < datas.size(); i++) {			ret[i] = datas.get(i);		}		return ret;	}	/**	 * �������烽��ゆ�n����烽�琛���烽��ゆ�寮��瑙���烽�瑙���烽��ゆ�	 * 	 * @param n	 * @return	 */	public static boolean isPalindrome(Object n) {		char[] array = String.valueOf(n).toCharArray();		for (int i = 0, len = array.length, m = (len - 1) / 2; i < len; i++) {			if (i <= m) {				if (array[i] != array[len - i - 1]) {					return false;				}			}		}		return true;	}	public static boolean isPermutation(int n1, int n2) {		int[] thisd = new int[10];		while (n1 > 0) {			thisd[n1 % 10]++;			n1 /= 10;		}		while (n2 > 0) {			thisd[n2 % 10]--;			n2 /= 10;		}		for (int i = 0; i < thisd.length; i++) {			if (thisd[i] != 0) {				return false;			}		}		return true;	}	/**	 * ����烽��ゆ�涓���ゆ�����烽��ゆ�n����烽��ゆ�����烽��ゆ���茎璁规�����烽��ゆ�����峰�����烽��ゆ�	 * ����烽��ゆ�姘��锟介��ヤ�纰�����纰��i浣���ゆ�绀轰负1���������烽��ゆ�绀洪��ゆ����������ゆ�����	 * 烽��ゆ������ (1<=i<=9)����� * 纭���ゆ�d����锋病���������烽��ゆ�����烽��ゆ�����烽�锟�	 * *	 * 	 * @param d	 * @return	 */	public static int getDigitPos(int d) {		int p = 0;		while (d > 0) {			int tmp = d % 10;			p |= (1 << (tmp - 1));			d /= 10;		}		return p;	}	public static boolean isCube(long e) {		double t = Math.pow(e, 1d / 3);		return t == (long) t;	}	public static boolean isSquare(long e) {		double t = Math.pow(e, 0.5);		return t == (long) t;	}	public static int getSize(int n) {		// best way		if (n == 0) {			return 0;		} else if (n < 0) {			return ((int) Math.log10(Math.abs(n))) + 1;		} else {			return ((int) Math.log10(n)) + 1;		}	}	public static void print(String split, int... data) {		for (int j = 0; j < data.length; j++) {			System.out.print(j == (data.length - 1) ? data[j]					: (data[j] + split));		}	}	public static void print(int... data) {		print(" ", data);	}	public static void print(String split, int[][] data) {		for (int i = 0; i < data.length; i++) {			for (int j = 0; j < data[i].length; j++) {				System.out.print(j == (data[i].length - 1) ? data[i][j]						: (data[i][j] + split));			}			System.out.println();		}	}	public static void print(int[][] data) {		print(" ", data);	}	/**	 * 	 * @param a	 * @param b	 * @return true ����烽�锟介��版�������烽�锟�	 */	public static boolean isFactorOf(long a, long b) {		return b % a == 0;	}	/**	 * ����烽��ゆ�����ゆ�����������烽��ゆ���拷����烽��ゆ�����烽�琛���存�	 * 	 * @param FOR_Permutation	 * @return	 */	public static int sumOfDigits(String data) {		int s = 0;		for (int i = 0; i < data.length(); i++) {			s += (int) (data.charAt(i) - '0');		}		return s;	}	/**	 * ���������烽��ゆ�����烽��ゆ�����锋�����ゆ�����烽��ゆ����������烽��ゆ�����烽��ゆ�m	 * 	 * @http://math.ntnu.edu.tw/~li/ent-html/node10.html#sn	 * @param m	 * @param primes	 * @return	 */	public static int sumDivisor(int m, int[] primes) {		int n = m;		int sum = 1;		int sq = (int) Math.sqrt(n);		for (int i = 0; i < primes.length; i++) {			int p = primes[i];			if (p > sq) {				break;			}			int j = 1;			for (; n % p == 0 && n > 1; n /= p, j++)				;			if (j > 1) {				sum *= (Math.pow(p, j) - 1) / (p - 1);				sq = (int) Math.sqrt(n);			}		}		if (n > 1) {			sum *= (1 + n);		}		return sum - m;	}	/**	 * ����烽��ゆ�����烽��ゆ�G����烽��ゆ�浣���ゆ�����烽�琛���存�	 * 	 * @return	 */	public static int sumOfDigits(int data) {		int s = 0;		while (data > 0) {			s += data % 10;			data /= 10;		}		return s;	}	public static int sumOfDigits(long data) {		int s = 0;		while (data > 0) {			s += data % 10;			data /= 10;		}		return s;	}	/**	 * 判断v是否可能是素数，是素数的概率为：1-1/2^certainty	 * 	 * @return	 */	public static boolean isProbablePrime(long v, int certainty) {		return BigInteger.valueOf(v).isProbablePrime(certainty);	}	/**	 * 判断v是否可能是素数，是素数的概率为：1-1/2^certainty 这个方法也是用Miller	 * Rabin算法，只是没用BigInteger，在long范围内免创建去重量级对象BigInteger	 * 	 * @return	 */	public static boolean isProbablePrimeMillerRabin(long n, int certainty) {		// TODO		return false;	}	/**	 * 从左边去掉一个数字后还是prime	 * 	 * @param v	 * @return	 */	public static boolean checkPrimeTruncatable(long v) {// 3797		long hold = v;		long t = 0;		int n = 1;		while (v > 0) {			t = v % 10 * n + t;			if (!Util.isProbablePrime(t, 100)) {				return false;			}			v /= 10;			if (v == 0) {				break;			}			if (!Util.isProbablePrime(v, 100)) {				return false;			}			n *= 10;		}		return true;	}	/**	 * 	 * @param d	 * @return	 */	public static boolean isPandigital1_9(int d) {		int mask = 0;		while (d > 0) {			int t = d % 10;			if (t == 0) {				return false;			}			mask |= 1 << (t - 1);			d /= 10;		}		if ((mask ^ MASK) != 0) {			return false;		}		return true;	}	public static boolean isPandigital1_9(String dStr) {		int mask = 0;		for (int i = 0; i < dStr.length(); i++) {			int t = dStr.charAt(i) - '0';			if (t == 0)				return false;			mask |= 1 << (t - 1);		}		if ((mask ^ MASK) != 0) {			return false;		}		return true;	}	public static boolean isPandigital1_n(int d, int n) {		if (n != getSize(d)) {			return false;		}		int MASK = (1 << n) - 1;		int mask = 0;		while (d > 0) {			int t = d % 10;			if (t == 0) {				return false;			}			mask |= 1 << (t - 1);			d /= 10;		}		if ((mask ^ MASK) != 0) {			return false;		}		return true;	}	/**	 * 十进制最小的全位数	 */	public static final int MIN_PANDIGITAL = 1023456789;	/**	 * 十进制全位数所有数字di，用2^di 或运算的结果	 */	public static final int EXPECTED_OR_RESULT = 1023;	/**	 * 最快的判断是否是全位数的方法。算法介绍： 假设n=dk...d3d2d1是全位数，则 2^d1 | 2^d2 | 2^d3 |...|2^dk =	 * 2^0 | 2^1 | 2^2 | ...|2^9 = 1023 = 2^10 -1=1111111111（二进制）	 * 	 * @param n	 * @return	 */	public static boolean isPandigital(long n) {		if (n >= MIN_PANDIGITAL) {			int digits = 0;			for (; n > 0; n /= 10) {				// 最右边数字对2的幂				digits |= 1 << (n - ((n / 10) * 10));				// 判断是否已经找全所有数字				if (digits == EXPECTED_OR_RESULT) {					return true;				}			}		}		return false;	}	/**	 * 判断用字符串n表示的十进制数是否是全位数	 * 	 * @return	 */	public static boolean isPandigital(String n) {		if (n.charAt(0) == '-') {			n = n.substring(1);		}		if (n.length() < 10) {			return false;		}		int digits = 0;		for (int i = 0; i < n.length(); i++) {			digits |= 1 << (n.charAt(i) - '0');			if (digits == EXPECTED_OR_RESULT) {				return true;			}		}		return false;	}	static int MASK = 0x1FF;	/**	 * 	 * (a + b) % n = (a % n + b % n) % n ����������br> (a - b) % n = (a % n - b	 * % n) % n ����������<br>	 * (a * b) % n = (a % n * b % n) % n ����������br> ab % n = ((a % n)b) % n	 * ����������br>	 * 	 * @return n�������娇�ゆ�	 */	public static long power(long n, long p) {		// ����烽��ゆ�n�������娇�ゆ�		int tmp = 1;		while (p > 1) {			// ���璁规�p����ゆ�����烽��ゆ��堕��ゆ�����烽��ゆ�浣���ゆ�涓�			if ((p & 1) != 0) {				tmp *= n; // �����涓洪��ゆ�����烽��ゆ����缁���风��归��ゆ�����烽��ゆ���拷			}			n *= n;			p >>= 1;		}		return n * tmp; // ����烽��ゆ�����烽��ゆ�姹��缁���风��归��ゆ�����烽��ゆ�����烽�杞匡拷�烽��ゆ�	}	/**	 * 	 * @param n	 * @param p	 * @param m	 * @return n <sup> p</sup> % m	 */	public static int powerMod(int n, int p, int m) {		int r = n % m;		int tmp = 1;		while (p > 1) {			if ((p & 1) != 0) {				tmp = (tmp * r) % m;			}			r = (r * r) % m;			p >>= 1;		}		return (r * tmp) % m;	}	/**	 * 求：n^p % m	 * 	 * @param n	 * @param p	 * @param m	 * @return	 */	public static long powerMod(long n, long p, long m) {		long r = n % m;		long tmp = 1;		while (p > 1) {			if ((p & 1) != 0) {// p 是奇数，则				tmp = (tmp * r) % m;			}			r = (r * r) % m;			p >>= 1;		}		return (r * tmp) % m;	}	public static BigInteger powerMod(BigInteger n, BigInteger p, BigInteger m) {		BigInteger r = n.mod(m);		BigInteger tmp = BigInteger.ONE;		while (p.compareTo(BigInteger.ONE) > 0) {			if (p.and(BigInteger.ONE).signum() != 0) {// p 是奇数，则				tmp = (tmp.multiply(r)).mod(m);			}			r = r.multiply(r).mod(m);			p = p.divide(BigInteger.valueOf(2L));		}		return r.multiply(tmp).mod(m);	}	/**	 * 递归法求：n^p % m	 * 	 * @param n	 * @param p	 * @param m	 * @return	 */	public static long powerMod2(long n, long p, long m) {		if (p == 0) {			return 1;		} else if (p == 1) {			return n % m;		}		long tmp = powerMod2(n, p / 2, m);		tmp = tmp * tmp % m;		if ((p & 1) != 0) {			tmp = tmp * n % m;		}		return tmp;	}	/**	 * 	 * @see http://en.wikipedia.org/wiki/Pell%27s_equation	 * @see http://zh.wikipedia.org/zh/%E4%BD%A9%E5%B0%94%E6%96%B9%E7%A8%8B	 * @param n	 * @return	 */	public static BigInteger pell(int n) {		BigInteger p = BigInteger.ONE, k = BigInteger.ONE, x1 = BigInteger.ONE, y = BigInteger.ZERO;		BigInteger n1 = BigInteger.valueOf(n);		BigInteger n2 = BigInteger.valueOf(-n);		BigInteger sd1 = BigInteger.valueOf((long) Math.sqrt(n)).negate();		BigInteger x = null;		while (k.compareTo(BigInteger.ONE) != 0				|| y.compareTo(BigInteger.ZERO) == 0) {			p = k.multiply((p.divide(k).add(BigInteger.ONE))).add(p.negate());			BigInteger t = p.add(sd1).divide(k).multiply(k);			p = p.add(t.negate());			x = (p.multiply(x1).add(y.multiply(n1))).divide(k.abs());			y = (p.multiply(y).add(x1)).divide(k.abs());			k = (p.multiply(p).add(n2)).divide(k);			x1 = x;		}		return x;	}	private static void printPrime(int count) throws IOException {		BigInteger d = BigInteger.valueOf(2);		File f = new File("./prime.txt");		if (!f.exists()) {			f.createNewFile();		}		while (count-- >= 0) {			System.out.print(d.longValue() + ",");			d = d.nextProbablePrime();		}	}	/**	 * 	 * @param d	 * @return min integer greater than d	 */	public static int minIntGreaterThan(double d) {		return (int) Math.floor(d + 1);	}	/**	 * 	 * @param d	 * @return max integer lesser than d	 */	public static int maxIntLesserThan(double d) {		return (int) Math.ceil(d - 1);	}	/**	 * a<b<c	 * 	 * @param a	 * @param b	 * @param c	 * @return 是否是勾股数	 */	public static boolean gouGuShu(int a, int b, int c) {		final int BOUND = 46340;		if (c <= BOUND) {			return c * c - b * b == a * a;		} else {			return ((long) c) * c - ((long) b) * b == ((long) a) * a;		}	}	/**	 * 多项式相乘，a，b分别是多项式的系数矩阵，按系数从低到高的顺序排列，而且末尾不是0,即a代表的多项式的最高次为a.length-1,	 * 	 * @param a	 * @param b	 * @return	 */	public static int[] polyMultiply(int[] a, int[] b) {		int al = a.length;		int bl = b.length;		int l = (al - 1) + (bl - 1) + 1;		int[] c = new int[l];		for (int i = 0; i < al; i++) {			for (int j = 0; j < bl; j++) {				c[i + j] += a[i] * b[j];			}		}		return c;	}	/**	 * a = a1i + a2j + a3k = [a1, a2, a3]<br>	 * b = b1i + b2j + b3k = [b1, b2, b3]<br>	 * a × b = [a2b3 − a3b2, a3b1 − a1b3, a1b2 − a2b1]	 * 	 * @param x1	 * @param y1	 * @param x2	 * @param y2	 * @return	 */	// public int vectorProduct(int a1, int a2,int a3, int b1, int b2,int b3) {	//	// }	/**	 * 三个点 (x1,y1),(x2,y2),(x3,y3)是否构成三角形	 * 	 * 	 * @param x1	 * @param y1	 * @param x2	 * @param y2	 * @param x3	 * @param y3	 * @return	 */	public static boolean isTriangle(int x1, int y1, int x2, int y2, int x3,			int y3) {		return crossProduct(x2 - x1, y2 - y1, x3 - x1, y3 - y1) != 0;	}	public static boolean isTriangle(IntVector2D A, IntVector2D B, IntVector2D C) {		return crossProduct(B.x - A.x, B.y - A.y, C.x - A.x, C.y - A.y) != 0;	}	/**	 * 平面矢量叉积	 * 	 * @return	 */	public static int crossProduct(int x1, int y1, int x2, int y2) {		// (0,0,z),这里是z		return x1 * y2 - x2 * y1;	}	public static int crossProduct(IntVector2D u, IntVector2D v) {		// (0,0,z),这里是z		return u.x * v.y - v.x * u.y;	}	/**	 * 三角形 A(x1,y1),B(x2,y2),C(x3,y3)是否包含点 M(px,py)	 * 	 * 算法： 沿着三角形的边按顺时针方向走，判断该点是否在每条边的右边（这可以通过叉乘判断）， （1）先求出三个向量MA,MB,MC. <br/>	 * （2）计算MA X MB,MB X MC,MC X MA (X表叉乘)	 * 如果此三组的向量叉乘的结果都是同号的（或都正，或都负），即方向相同的，则说明点M在三角形每条边的同侧，即内部。否则必在外部！	 * 	 * 	 * @param x1	 * @param y1	 * @param x2	 * @param y2	 * @param x3	 * @param y3	 * @param px	 * @param py	 * @return	 */	public static boolean triangleContainsPoint(int x1, int y1, int x2, int y2,			int x3, int y3, int px, int py) {		IntVector2D MA = new IntVector2D(px - x1, py - y1);		IntVector2D MB = new IntVector2D(px - x2, py - y2);		IntVector2D MC = new IntVector2D(px - x3, py - y3);		int c1 = crossProduct(MA, MB);		int c2 = crossProduct(MB, MC);		int c3 = crossProduct(MC, MA);		if (c1 > 0 && c2 > 0 && c3 > 0) {			return true;		}		if (c1 < 0 && c2 < 0 && c3 < 0) {			return true;		}		return false;	}	/**	 * 	 * @param A	 * @param B	 * @param C	 * @param M	 * @return	 */	public static boolean triangleContainsPoint(IntVector2D A, IntVector2D B,			IntVector2D C, IntVector2D M) {		IntVector2D MA = new IntVector2D(M.x - A.x, M.y - A.y);		IntVector2D MB = new IntVector2D(M.x - B.x, M.y - B.y);		IntVector2D MC = new IntVector2D(M.x - C.x, M.y - C.y);		int c1 = crossProduct(MA, MB);		int c2 = crossProduct(MB, MC);		int c3 = crossProduct(MC, MA);		if (c1 > 0 && c2 > 0 && c3 > 0) {			return true;		}		if (c1 < 0 && c2 < 0 && c3 < 0) {			return true;		}		return false;	}	public static boolean isHarshadNumber(long n) {		return n % sumOfDigits(n) == 0;	}	public static boolean isStrongRightTruncatableHarshadNumber(long n) {		int[] digits = toDigit(n);		int sum = (int) sum(digits);		if (n % sum == 0) {			if (!isProbablePrime(n / sum, 100)) {				return false;			}		} else {			return false;		}		for (int i = digits.length - 1; i > 0; i--) {			sum -= digits[i];			n = n / 10;			if (!(n % sum == 0)) {				return false;			}		}		return true;	}	/**	 * for each multiplier[i][j] = m, j = i * m % 10	 */	public static int[][] multiplier = new int[10][10];	static {		for (int i = 0; i < 10; i++) {			for (int m = 0; m < 10; m++) {				int j = i * m % 10;				multiplier[i][j] = m;			}		}	}	/**	 * get the min integer n which endWiths p1 and can be divided by p2	 * 	 * @param p1	 * @param p2	 * @return	 */	public static long getProductEndWith(int p1, int p2) {		int i = getRightmostKthDigit(p2, 0);// rightmost digit of p2		long n = 0;		int L = ((int) Math.log10(p1)) + 1;// size of digits of p1		for (int k = 0; k < L; k++) {// from the rightmost xth			// (10 + p1右起第k位 - n右起第k位 )%10得到这次乘积的个位数字j			int j = (10 + getRightmostKthDigit(p1, k) - getRightmostKthDigit(n,					k)) % 10;			long m = multiplier[i][j];// 乘积的各位数字是j，一个因子是i，则另一个因子是m			n += p2 * (m * (int) Math.pow(10, k));// 因子m在k位上，所以要乘10^k然后加到n		}		return n;	}	/**	 * get the rightmost kth digit of n,k start from 0;	 */	public static int getRightmostKthDigit(long n, int k) {		return (int) ((n / POWER_OF_TEN_LONG[k]) % 10);	}			public static void main(String[] args) {		// System.out.println(getProductEndWith(999983, 1000003));		System.out.println(getProductEndWith(999983, 1000003));// 666662999983	}}